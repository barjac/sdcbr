#!/bin/bash
######################
# sdcbr
# SD Card Backup and Restore
#
# Backs up an SD card interactively as a compressed image.
# Restores a previously backed up compressed image to a similar size or larger SD card.
# Suitable for backing up Raspberry Pi operating system cards.
#
######################
#set -x
set -o pipefail
DBG=1

confirm() {
params=( "$1" "$2" "$3" "$4" "$5" )
rval=3
while ((rval > 2));do
    echo -ne "${params[0]} ${params[1]} "
    ans=
    rval=
    IFS= read -r -n1 ans
    if [ -z "$ans" ] || ((${#ans} > 1)); then
        ((rval=3))
    else
        case "$ans" in
            [${params[2]}]*)
                rval=0
                ;;
            [${params[3]}]*)
                rval=1
                ;;
            [${params[4]}]*)
                rval=2
                ;;
            *)
                rval=3
                ;;
        esac
    fi
done
return $rval
}

listdrives() {
# Read all the disks
drives=$(fdisk -l 2>/dev/null | grep "Disk /dev" | grep -v ram | grep -v part| cut -d ' ' -f2|cut -d: -f1|tr '\n ' ' ')
}

detectusb() {
# Loop until found
while true; do
    echo
    if confirm "Make sure the USB stick or SD card is UNPLUGGED now. Ready?" "[Y/N]" "Yy" "Nn";then
        listdrives
        [[ $dbg == 1 ]] && echo "${drives[@]}"
        a=${drives[*]}
        echo -n -e "\nPLUG IN the device to use now. (ESC to abort)\nDetecting."
        while true; do
            listdrives
            ((dbg == 1)) && echo "${drives[@]}"
            b=${drives[*]}
            read -r -s -n1 -t1 key
            if [[ $key = $'\e' ]]; then
                ((esc=1))
                echo -e "\nBye!"
                exit 1
            else 
                key=""
            fi
            ((dbg == 1)) &&  echo "a=${#a[@]}, b=${#b[@]}"
            ((dbg == 1)) &&  echo "a=$a, b=$b"
            [[ ${a[*]} != "${b[*]}" ]] && break
            echo -n "."
        done
        [[ ${a[*]} == "${b[*]}" ]] || ((esc == 1)) && { echo; continue; }
        echo
        echo
    else
        echo -e "\nBye!"; exit 0
    fi
    for item1 in ${b[@]}; do
        for item2 in ${a[@]}; do
            found=0
            if [[ "$item1" == "$item2" ]]; then
                found=1; break
            fi
        done
        [[ $found = 1 ]] && continue
        DISK="$item1"; break
    done
    echo -e "Detected device is $DISK which has the following structure:\n"
    lsblk "$DISK"
    break
done
}

get_used_blocks() {
(( DBG )) && echo "Disk in use: $DISK"
    BS=${2:-1M}

    # Get last used sector
    SECTORS_TO_SAVE=$(fdisk -l "$DISK" | awk '/^\/dev/ {print $3}' | sort -n | tail -1)
    echo "Last used sector: $SECTORS_TO_SAVE"

    # Get sector size (bytes)
    SECTOR_SIZE=$(fdisk -l "$DISK" | awk '/Sector size/ {print $4; exit}')
    echo "Sector size: $SECTOR_SIZE bytes"

    # Calculate total bytes to save (include +1)
    BYTES_TO_SAVE=$(((SECTORS_TO_SAVE + 1) * SECTOR_SIZE))
    echo "Total bytes to save: $BYTES_TO_SAVE"

    # Convert BS to bytes (handle 'M' or 'K' suffixes)
    case "$BS" in
        *M) BS_BYTES=$(( ${BS%M} * 1048576 )) ;;
        *K) BS_BYTES=$(( ${BS%K} * 1024 )) ;;
        *)  BS_BYTES=$BS ;;
    esac
    echo "Block size: $BS_BYTES bytes"

    # Round up division to next whole block
    COUNT=$(( (BYTES_TO_SAVE + BS_BYTES - 1) / BS_BYTES ))

    # Add safety margin (8 MiB)
    COUNT=$(( COUNT + (8 * 1048576 / BS_BYTES) ))
    echo "Count: $COUNT blocks"
}


get_dir() {
user=$(users|grep -v root|cut -d ' ' -f1)
(( DBG )) && echo "User = $user"
DIR=
if [[ -f /home/"$user"/.sdcbr_dir ]]; then
#&& [[ -d $(cat /home/"$user"/.sdcbr_dir) ]]; then
    DIR=$(cat /home/"$user"/.sdcbr_dir)
else
    if confirm "Please select a default directory for your backups now OK?" "[Y/N]" "Yy" "Nn"; then
        DIR=$(zenity --file-selection --directory 2> /dev/null)
    fi
fi
echo
if confirm "Keep your default backup DIRECTORY as $DIR ?" "N/Y" "Nn" "Yy"; then
    DIR=$(zenity --file-selection --directory --filename="$DIR"/ 2> /dev/null)
    sleep 0.5
    echo -e "\n\nYou selected $DIR"
    if confirm "\nSave this directory as new default?" "[Y/N]" "Yy" "Nn"; then
        echo "$DIR" > /home/"$user"/.sdcbr_dir
    fi
#echo -e "\n\nBackups will be saved to and restored from $DIR"
else
#[[ -f /home/$user/.sdcbr_dir ]] && DIR=$(cat /home/$user/.sdcbr_dir)
    if (( ${#DIR} == 0 )); then
        DIR=/home/"$user"
    fi
#echo -e "\n\nBackups will be saved to and restored from $DIR"
fi
echo -e "\n\nBackups will be saved to and restored from $DIR"
}

chkdeps() {
echo "Just one moment - checking dependencies..."
deps=(pv coreutils zenity)
for dp in "${deps[@]}";do
    if rpm -q "$dp" > /dev/null ; then
        continue
    else
        if confirm "${dp} is not installed - (I)nstall or (S)kip" "[I/S]" "Ii" "Ss";then
            if urpmi "$dp"; then
                exit 1
            fi
        else
            continue
        fi
    fi
done
return 0
}

do_backup() {
loop=1
while ((loop > 0)); do
    echo
    IFS= read -r -p "Enter a name for the backup file (date/time will be appended automatically) " FILE
    FILE="${FILE}_$(date +%y%m%d%H%M).zst"
    FILE="${DIR}/${FILE}"
    if confirm "Backup of $DISK will be created as $FILE OK?" "Y/N/Q" "Yy" "Nn" "Qq"; then
        loop=0; continue
    elif (( $? == 2 )); then
        echo -e "\nBye!"; exit 0
    fi
done
echo
echo "Starting backup, this may take a long time.... please wait!"
echo

get_used_blocks

BS="1M"               # block size for backup
THREADS=$(nproc)      # number of CPU cores for compression

echo "Backing up $DISK to $FILE..."
echo "dd if="$DISK" bs="$BS" iflag=fullblock status=progress | zstd -T"$THREADS" -C19 -o "$FILE""

if dd if="$DISK" bs="$BS" iflag=fullblock status=progress | zstd -T"$THREADS" -C19 -o "$FILE"; then
    echo "Backup complete and saved as $FILE"
else
    echo "Backup failed" >&2
fi
}

do_restore() {
    local VERIFY_MODE=0
    # Optional argument: --verify
    if [[ "$1" == "--verify" ]]; then
        VERIFY_MODE=1
    fi

    # -----------------------------
    # 0️⃣ User confirmations
    # -----------------------------
    IFS= read -r -p "Select the file to restore from now? [Y/N] " -n 1
    echo
    [[ ! $REPLY =~ ^[Yy]$ ]] && { echo "User aborted operation!"; exit 1; }

    local loop=1
    while ((loop > 0)); do
        FILE=$(zenity --file-selection --filename="$DIR"/ 2> /dev/null)
        [[ ! -f "$FILE" ]] && { echo "File not found!"; sleep 2; continue; }
        loop=0
    done

    IFS= read -r -p "Are you sure you want to restore $FILE to $DISK [Y/N]? " -n 1
    echo
    [[ ! $REPLY =~ ^[Yy]$ ]] && { echo "User aborted operation!"; exit 1; }

    IFS= read -r -p "Are you ABSOLUTELY sure you want to overwrite $DISK [Y/N]? " -n 1
    echo
    [[ ! $REPLY =~ ^[Yy]$ ]] && { echo "User aborted operation!"; exit 1; }

    # -----------------------------
    # 1️⃣ Determine decompression command
    # -----------------------------
    case "$FILE" in
        *.gz)  DECOMP="gzip -dc";  VERIFY_CMD="gzip -t" ;;
        *.zst) DECOMP="zstd -d";   VERIFY_CMD="zstd -t -q" ;;
        *) echo "Error: Unknown backup format (.gz or .zst only)"; exit 1 ;;
    esac

    echo "Verifying backup file integrity..."
    if ! $VERIFY_CMD "$FILE" >/dev/null 2>&1; then
        echo "Integrity test FAILED — file is corrupt or incomplete!" >&2
        exit 1
    fi
    echo "Integrity OK."

    # -----------------------------
    # 2️⃣ Determine image size for block tuning
    # -----------------------------
    if [[ "$FILE" == *.gz ]]; then
        IMG_SIZE_BYTES=$(gzip -l "$FILE" | awk 'NR==2 {print $2}')
    elif [[ "$FILE" == *.zst ]]; then
        IMG_SIZE_BYTES=$(zstd -lv "$FILE" 2>/dev/null | awk '/Decompressed Size/ {gsub(/[^0-9]/,"",$3); print $3; exit}')
    fi
    [[ -z "$IMG_SIZE_BYTES" ]] && IMG_SIZE_BYTES=$((8*1024*1024*1024))  # fallback 8 GB

    # -----------------------------
    # 3️⃣ Pick block size
    # -----------------------------
    if (( IMG_SIZE_BYTES < 4*1024*1024*1024 )); then
        BS="1M"
    elif (( IMG_SIZE_BYTES < 16*1024*1024*1024 )); then
        BS="2M"
    else
        BS="4M"
    fi

    echo
    echo "Backup file: $FILE"
    echo "Target device: $DISK"
    echo "Block size: $BS"
    echo "Using decompressor: $([[ "$FILE" == *.gz ]] && echo gzip || echo zstd (multi-core))"
    echo

    # -----------------------------
    # 4️⃣ Restore pipeline with clean progress
    # -----------------------------
    set -o pipefail
    echo "Starting decompression and restore... (this may take a few seconds to begin)"
    echo

    if [[ "$FILE" == *.zst ]]; then
        if ! $DECOMP "$FILE" -c -T0 | pv -N "Restoring" | dd bs="$BS" iflag=fullblock of="$DISK" status=none; then
            echo "Restore failed! Check SD card and backup integrity." >&2
            exit 1
        fi
    else
        if ! $DECOMP "$FILE" | pv -N "Restoring" | dd bs="$BS" iflag=fullblock of="$DISK" status=none; then
            echo "Restore failed! Check SD card and backup integrity." >&2
            exit 1
        fi
    fi

    sync
    echo "Restore complete from $FILE to $DISK"

    # -----------------------------
    # 5️⃣ Optional post-restore spot check
    # -----------------------------
    if (( VERIFY_MODE )); then
        VERIFY_BYTES=$((1*1024*1024))  # 1 MB slices
        TMPDIR=$(mktemp -d)
        echo
        echo "Performing automatic post-restore integrity check..."
        echo "Verifying first and last $((VERIFY_BYTES/1024)) KB of restored image..."

        # First slice from backup
        if [[ "$FILE" == *.zst ]]; then
            $DECOMP "$FILE" -c -T0 | dd bs=1M count=1 of="$TMPDIR/beg_ref.bin" status=none
            $DECOMP "$FILE" -c -T0 | tail -c "$VERIFY_BYTES" > "$TMPDIR/end_ref.bin"
        else
            gzip -dc "$FILE" | dd bs=1M count=1 of="$TMPDIR/beg_ref.bin" status=none
            gzip -dc "$FILE" | tail -c "$VERIFY_BYTES" > "$TMPDIR/end_ref.bin"
        fi

        # First and last slice from restored device
        dd if="$DISK" bs=1M count=1 iflag=fullblock of="$TMPDIR/beg_dev.bin" status=none
        OFFSET=$((BYTES_TO_SAVE - VERIFY_BYTES))
        dd if="$DISK" bs=1 count="$VERIFY_BYTES" skip="$OFFSET" iflag=skip_bytes,count_bytes \
            of="$TMPDIR/end_dev.bin" status=none

        # Compare hashes
        REF_BEG=$(sha256sum "$TMPDIR/beg_ref.bin" | awk '{print $1}')
        DEV_BEG=$(sha256sum "$TMPDIR/beg_dev.bin" | awk '{print $1}')
        REF_END=$(sha256sum "$TMPDIR/end_ref.bin" | awk '{print $1}')
        DEV_END=$(sha256sum "$TMPDIR/end_dev.bin" | awk '{print $1}')

        echo "Start  : $( [[ "$REF_BEG" == "$DEV_BEG" ]] && echo "OK" || echo "MISMATCH!" )"
        echo "End    : $( [[ "$REF_END" == "$DEV_END" ]] && echo "OK" || echo "MISMATCH!" )"

        if [[ "$REF_BEG" == "$DEV_BEG" && "$REF_END" == "$DEV_END" ]]; then
            echo "✅ Quick post-restore integrity check PASSED"
        else
            echo "⚠️  Warning: Mismatch detected! The restore may be incomplete or corrupted."
        fi

        rm -rf "$TMPDIR"
    fi
}

############## Main routine ##############
clear
echo "############## Welcome to SD Card Backup Restore ##############"
# Check we are root
((UID)) && { echo "You must be root to run $0"; exit 1; }
# Check for required packages
chkdeps
# Get or confirm the backup dir path
get_dir
# Detect the USB device to work with
detectusb

if confirm "\nDo you want to (B)ackup (R)estore or (Q)uit?" "B/R/Q" "Bb" "Rr" "Qq"; then
        echo
        do_backup
elif (( $? == 1 )); then
        echo
        do_restore --verify
else
        echo -e "\nBye!"
        exit 0
fi
